#!/usr/bin/env python3

########################################################################
# BME205 Asgn5: problem 24
# Author: James Larbalestier
# Group: Tyler Gaw
########################################################################
'''
Viterbi learning

Given: A sequence of emitted symbols x = x1 ... xn in an alphabet A, generated by a k-state 
HMM with unknown transition and emission probabilities, initial Transition and Emission 
matrices and a number of iterations i.

Return: A matrix of transition probabilities Transition and a matrix of emission probabilities 
Emission that maximizes Pr(x, π) over all possible transition and emission matrices and over 
all hidden paths π.


'''
from collections import Counter
def main(inFile = None):
    def viterbiAlgorithm(x):
        n = len(x)
        m = len(pathStates)

        # Initialize the Viterbi matrix
        viterbiMatrix = [[0.0] * m for _ in range(n)]
        backtrackMatrix = [[''] * m for _ in range(n)]

        # Initialize the first column of the Viterbi matrix
        for i in range(m):
            viterbiMatrix[0][i] = emissMatrix[i][emissionStates.index(x[0])]

        # Fill in the rest of the Viterbi matrix
        for j in range(1, n):
            for i in range(m):
                max_prob = 0.0
                max_state = ''
                for k in range(m):
                    prob = viterbiMatrix[j - 1][k] * transMatrix[k][i] * \
                        emissMatrix[i][emissionStates.index(x[j])]
                    if prob > max_prob:
                        max_prob = prob
                        max_state = pathStates[k]
                viterbiMatrix[j][i] = max_prob
                backtrackMatrix[j][i] = max_state

        # Find the last state with the maximum probability
        lastStateIndex = viterbiMatrix[-1].index(max(viterbiMatrix[-1]))
        path = [pathStates[lastStateIndex]]

        # Backtrack to reconstruct the optimal path
        for j in range(n - 1, 0, -1):
            lastStateIndex = pathStates.index(
                backtrackMatrix[j][lastStateIndex])
            path.insert(0, pathStates[lastStateIndex])
        return ''.join(path)


    def getCounts(basePath, outcomePath, baseStates):
        emitDic = {base: [] for base in baseStates}
        transDic = {base: [] for base in baseStates}
        for i in range(len(basePath)):
            pathState = basePath[i]
            emission = outcomePath[i]
            emitDic[pathState].append(emission)
            try:
                state2 = basePath[i+1]
                transDic[pathState].append(state2)
            except IndexError:
                pass
        for key, value in transDic.items():
            transDic[key] = Counter(value)
        for key, value in emitDic.items():
            emitDic[key] = Counter(value)
        return transDic, emitDic


    def probMatrix(states, outcomes, counts):
        matrix = []
        for state in states:  # x
            column = []  # ys of x
            ref = counts[state]
            total = sum(ref.values())
            for eState in outcomes:
                count = ref[eState]
                try:
                    prob = count / total
                except ZeroDivisionError:
                    prob = 1/len(emissionStates)
                column.append(prob)
            matrix.append(column)
        return matrix


    def formatMatrix(matrix, rowLabels, colLabels):
        formattedMatrix = []
        # Header row
        headerRow = ["    "] + colLabels
        formattedMatrix.append("\t".join(headerRow))
        # Data rows
        for i, (label, row) in enumerate(zip(rowLabels, matrix)):
            formatted_row = [label]
            formatted_row.extend([f"{round(num, 3):.3f}".rstrip(
                '0').rstrip('.') if num > 0.001 else '0.0' for num in row])
            formattedMatrix.append("\t".join(formatted_row))
        return "\n".join(formattedMatrix)

 
    with open(inFile) as fh:
        iter = int(fh.readline().rstrip())
        junk = fh.readline().rstrip()
        observedEmissions = fh.readline().rstrip()
        junk = fh.readline().rstrip()
        emissionStates = fh.readline().rstrip().split()
        junk = fh.readline().rstrip()
        pathStates = fh.readline().rstrip().split()
        junk = fh.readline().rstrip()
        junk = fh.readline().rstrip()
        transMatrix = []
        for i in range(len(pathStates)):
            line = fh.readline().rstrip()
            vals = [float(value) for value in line.split('\t')[1:]]
            transMatrix.append(vals)
        junk = fh.readline().rstrip()
        junk = fh.readline().rstrip()
        emissMatrix = []
        for i in range(len(pathStates)):
            line = fh.readline().rstrip()
            vals = [float(value) for value in line.split('\t')[1:]]
            emissMatrix.append(vals)


    for i in range(iter):
        workingStates = viterbiAlgorithm(observedEmissions)  # path
        # def               getCounts(basePath, outcomePath, baseStates):
        transDic, emitDic = getCounts(workingStates, observedEmissions, pathStates)
        #         def probMatrix(states, outcomes, counts):
        emissMatrix = probMatrix(pathStates, emissionStates, emitDic)
        transMatrix = probMatrix(pathStates, pathStates, transDic)

    # def formatMatrix(matrix, rowLabels, colLabels):
    print(formatMatrix(transMatrix, pathStates, pathStates))
    print('--------')
    print(formatMatrix(emissMatrix, pathStates, emissionStates))
if __name__ == "__main__":
    main(inFile = 'rosalind_ba10i.txt')

