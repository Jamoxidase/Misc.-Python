#!/usr/bin/env python3

########################################################################
# BME205 Asgn5: problem 23
# Author: James Larbalestier
# Group: Tyler Gaw
########################################################################
'''
HMM Parameter Estimation Problem

Given: A sequence of emitted symbols x = x1 . . . xn in an alphabet ∑ and a path π = π1 . . . πn 
generated by a k-state HMM with unknown transition and emission probabilities.

Return: A matrix of transition probabilities Transition and a matrix of emission probabilities 
Emission that maximize Pr(x,π) over all possible matrices of transition and emission probabilities.
'''

from collections import Counter

def getCounts(basePath, outcomePath, baseStates):
    emitDic = {base: [] for base in baseStates}
    transDic = {base: [] for base in baseStates}
    for i in range(len(basePath)):
        pathState = basePath[i]
        emission = outcomePath[i]
        emitDic[pathState].append(emission)
        try:
            state2 = basePath[i+1]
            transDic[pathState].append(state2)
        except IndexError:
            pass
    for key, value in transDic.items():
        transDic[key] = Counter(value)
    for key, value in emitDic.items():
        emitDic[key] = Counter(value)
    return transDic, emitDic

def probMatrix(states, outcomes, counts):
    matrix = []
    for state in states: #x
        column = [] #ys of x
        ref = counts[state]
        total = sum(ref.values())
        for eState in outcomes:
            count = ref[eState]
            try:
                prob = count / total
            except ZeroDivisionError:
                prob = 1/len(outcomes)
            column.append(prob)
        matrix.append(column)
    return matrix

def formatMatrix(matrix, rowLabels, colLabels):
    formattedMatrix = []
    # Header row
    headerRow = ["    "] + colLabels
    formattedMatrix.append("\t".join(headerRow))
    # Data rows
    for i, (label, row) in enumerate(zip(rowLabels, matrix)):
        formatted_row = [label]
        formatted_row.extend([f"{round(num, 3):.3f}".rstrip(
            '0').rstrip('.') if num > 0.001 else '0.0' for num in row])
        formattedMatrix.append("\t".join(formatted_row))
    return "\n".join(formattedMatrix)


def main(inFile = None): 
    with open(inFile) as fh:
        emissions = fh.readline().rstrip()
        junk = fh.readline().rstrip()
        emissionStates = fh.readline().rstrip().split()
        junk = fh.readline().rstrip()
        path = fh.readline().rstrip()
        junk = fh.readline().rstrip()
        pathStates = fh.readline().rstrip().split()
        junk = fh.readline().rstrip()
        junk = fh.readline().rstrip()


        '''        emissions = "yzzzyxzxxx"
        path =      "BBABABABAB"
        emissionStates = ['x','y','z']
        pathStates =     ['A', 'B', 'C']'''

        #def getCounts(basePath, outcomePath, baseStates):
        transDic, emitDic = getCounts(path, emissions, pathStates)

        #def probMatrix(states, outcomes, counts):
        boo = probMatrix(pathStates, emissionStates, emitDic)
        poo = probMatrix(pathStates, pathStates, transDic)

        #def formatMatrix(matrix, rowLabels, colLabels):
        print(formatMatrix(poo, pathStates, pathStates))
        print('--------')
        print(formatMatrix(boo, pathStates, emissionStates))

if __name__ == "__main__":
    main(inFile = 'rosalind_ba10h.txt')