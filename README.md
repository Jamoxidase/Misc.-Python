# Misc.-Python

Positional Burrows-Wheeler Transform (PBWT)

PBWT employs a sorted suffix array run-length compression approach that enables efficient and scalable identification of maximal matches given a haplotype set of M sequences with N bi-allelic variable sites in O(NM) time compared to O(NM^2) expected from naive pairwise comparison.

Algorithm 1 - constructReversePrefixSortMatrix()

Calculates the reverse prefix sort matrix A for a given collection of binary strings X. It defines an "ith prefix sort" as a lexicographic sorting of the set of ith prefixes, where each prefix is defined as the substring of length i from the binary strings in X. Likewise, an "ith reverse prefix sort" is a lexicographic sorting of the set of ith prefixes after each prefix is reversed. The function takes a list of binary strings, X, as input and returns an Mx(N+1) Numpy integer array, where M is the number of strings in X, and N is the length of each string. The algorithm iterates over each position in the binary strings and processes each haplotype sample. For each position, it separates the haplotypes into two lists based on the allele (0 or 1) at that position. Then, it updates the matrix A with the indices of haplotypes sorted according to their alleles in the current position. Finally, it returns the resulting matrix A.

Algorithm 2 - constructYFromX()

In continuation of the previous task, we aim to construct matrix Y, with dimensions MxN, where M represents the number of haplotypes and N signifies the length of biallelic positions. Each element Y[i,j] in matrix Y is derived from matrix X using the Reverse Prefix Sort Matrix (RPSM) computed in the earlier problem. To accomplish this, we utilize the constructReversePrefixSortMatrix(X) function to obtain the RPSM, denoted as matrix A. We then extract the dimensions of A to determine the dimensions of matrix Y, namely M and N. Subsequently, matrix Y is initialized as an empty matrix with dimensions Mx(N-1). This adjustment is made to accommodate the extraction of elements from matrix X based on the indices provided by matrix A. The algorithm iterates over each position (i, j) in matrix Y. For each position, it retrieves the index from matrix A, indicating the haplotype string in X. It then extracts the character from the corresponding position in the haplotype string and assigns it to the corresponding position in matrix Y. Following the completion of all computations and assignments, matrix Y is returned as the output of the algorithm. In terms of complexity analysis, the algorithm exhibits an asymptotic time complexity of O(MN), where M represents the number of haplotypes and N denotes the length of biallelic positions. This complexity arises from the iteration over each position in matrix Y. Similarly, the space complexity is O(MN) due to the storage of matrix Y along with auxiliary variables utilized during computation.

Algorithm 3 - constructXFromY()

The algorithm addresses Problem 3, where matrix Y represents a transformation of matrix X, and the task is to reconstruct matrix X from matrix Y, returning X as a list of strings as specified in problem 1. To achieve this, the algorithm starts by extracting the dimensions of matrix Y, denoted as M and N. It then initializes matrix X as an empty matrix with dimensions MxN, using the numpy array data structure. Next, the algorithm iterates over each column in matrix Y. For each column, it performs the following steps:

Builds the first column of the auxiliary matrix A_i, containing indices from 0 to M-1.
Constructs matrix X column-wise using the indices from A_i and the corresponding column of matrix Y.
Sorts the indices in A_i based on the values in the current column of matrix X.
Once the iteration over all columns is complete, the algorithm converts matrix X back into a list of strings, where each string represents a haplotype. This conversion is achieved by joining the elements of each row in matrix X and converting them into strings. In terms of complexity analysis: The algorithm exhibits an asymptotic time complexity of O(MN(logM)), where M represents the number of haplotypes and N denotes the length of biallelic positions. This complexity arises from the sorting operation performed on the auxiliary matrix A_i for each column of matrix Y. As for space complexity, it remains O(M*N) due to the storage of matrix X and auxiliary variables during computation. Additionally, matrix Y can be utilized for various purposes, such as implementing the Burrows-Wheeler Transform (BWT), as it represents a reversible transformation of the input array X. Finally, to enhance the efficiency of storing matrix Y, one could explore alternative data structures that can compress runs of identical values, especially in the case of longer sequences.

Algorithm 4 - constructCommonSuffixMatrix(), computeCSL()

The algorithm addresses Problem 4, which involves computing the common suffix lengths between substrings of matrix X based on the indices provided by matrix A. To achieve this, the algorithm defines a function computeCSL to compute the length of the common suffix between two given substrings s1 and s2. This function iterates over the substrings from the end and compares characters until a mismatch is encountered, returning the length of the common suffix. Next, the main function constructCommonSuffixMatrix takes matrix A and matrix X as input. It initializes matrix D as an MxN numpy array filled with zeros to store the common suffix lengths. The algorithm iterates over the rows of matrix A starting from the second row (i.e., indices 1 to M-1) and for each row, iterates over the columns. For each cell (i, j) in matrix D, it extracts the substrings from matrix X corresponding to the indices provided by matrix A. Then, it computes the length of the common suffix between these substrings using the computeCSL function and stores the result in matrix D. Finally, the algorithm returns the computed matrix D containing the common suffix lengths. In terms of complexity analysis: - The algorithm exhibits an asymptotic time complexity of O(MNN), where M represents the number of haplotypes and N denotes the length of biallelic positions. This complexity arises from the nested loops iterating over the rows and columns of the matrices A and D, respectively, and the additional loop within the computeCSL function. - As for space complexity, it remains O(M*N) due to the storage of matrix D during computation. This algorithm efficiently computes the common suffix lengths between substrings of matrix X, providing valuable insights into the similarity between haplotypes in genetic sequence analysis.

Algorithm 5 - getLongMatches()

The provided algorithm addresses Problem 5, which involves enumerating all long matches ending at a specified position within pairs of strings in a given set X. A long match is defined as a common substring between two strings that is longer than a specified threshold minLength and ends at the given position. The algorithm utilizes functions constructReversePrefixSortMatrix and constructCommonSuffixMatrix to prepare the necessary matrices A and D, respectively, which are then used to identify long matches efficiently. For each column j in the matrix X, the algorithm iterates over the strings in reverse prefix order. It partitions the strings based on the symbol at position j and stores them in arrays b and c. If the common suffix length between consecutive strings is less than the minLength, it reports all the long matches found so far and resets the arrays. This process continues until all columns are processed. In terms of complexity analysis: The algorithm's asymptotic time complexity is O(M^2 * N), where M is the number of haplotypes and N is their length (number of biallelic positions). This complexity arises from the nested loops iterating over the strings in X and the columns in the matrix. As for space complexity, it is O(M^2 * N), primarily due to the storage of matrices A and D, which have dimensions proportional to the number of haplotypes squared multiplied by the length of the strings. In refactoring the algorithm: Smarter data structures like suffix trees could potentially offer optimizations for faster lookup and comparison operations, potentially improving time efficiency. Alternative algorithms, such as using suffix trees, could be explored. Although the time complexity of suffix trees is also O(M^2 * N), they might offer better space efficiency and potentially lower time complexity with advanced algorithms. Overall, the algorithm efficiently identifies long matches between substrings of haplotypes, providing valuable insights into genetic sequence analysis.

This content is an extension of an assignment for Benedict Pattenâ€™s Computational Biology course at UCSC.

